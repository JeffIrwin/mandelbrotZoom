module fmod

implicit none

double precision, parameter :: e = exp(1.d0)

integer, parameter :: debug = 2

contains

!=======================================================================

! frm
!     1:  B & W      ASCII
!     2:  Grayscale  ASCII
!     3:  RGB        ASCII
!     4:  B & W      Binary
!     5:  Grayscale  Binary
!     6:  RGB        Binary
!
! b
!     Rank-two array of pixel values
!
! fname
!     File name without extension

subroutine writepbm(frm, b, fname)

character :: fname*(*), dat*256

integer :: frm, ix, iy, iunit
!integer, allocatable :: b(:,:)
character, allocatable :: b(:,:)

if (frm == 1) then

  ! B & W (0 and 1)
  open(newunit = iunit, file = trim(fname)//'.pbm')
  write(iunit, '(a)') 'P1'

else if (frm == 2) then

  ! Grayscale (0 - 255)
  open(newunit = iunit, file = trim(fname)//'.pgm')
  write(iunit, '(a)') 'P2'

else if (frm == 3) then

  ! RGB (0 - 255 triplets)
  open(newunit = iunit, file = trim(fname)//'.ppm')
  write(iunit, '(a)') 'P3'

else if (frm == 4) then

  ! B & W (0 and 1)
  open(newunit = iunit, file = trim(fname)//'.pbm')
  write(iunit, '(a)') 'P4'

else if (frm == 5) then

  ! Grayscale (0 - 255)
  open(newunit = iunit, file = trim(fname)//'.pgm')
  write(iunit, '(a)') 'P5'

else if (frm == 6) then

  ! RGB (0 - 255 triplets)
  open(newunit = iunit, file = trim(fname)//'.ppm', form = 'unformatted', access = 'direct', recl = 1)
  dat = 'P6'
  !write(iunit) 'P6'
  !write(iunit, rec = 1) trim(dat)
  write(iunit, rec = 1) 'P'
  write(iunit, rec = 2) '6'

else

  write(*,*)
  write(*,*) 'ERROR in writepbm'
  write(*,*) 'Invalid format'
  write(*,*) 'Valid values frm = 1 - 6'
  write(*,*)
  stop

end if

if (frm >= 1 .and. frm <= 3) then
  write(iunit, '(a)') '# Pixel bit map in netpbm format, generated by writepbm'
else
  write(iunit) '# Pixel bit map in netpbm format, generated by writepbm'
end if

if (frm >= 1 .and. frm <= 3) then
  if (frm == 1 .or. frm == 2) then
    write(iunit, '(i0, a, i0)') ubound(b, 1) - lbound(b, 1) + 1, ' ', ubound(b, 2) - lbound(b, 1) + 1
  else
    write(iunit, '(i0, a, i0)') (ubound(b, 1) - lbound(b, 1) + 1) / 3, ' ', ubound(b, 2) - lbound(b, 2) + 1
  end if
else
  if (frm == 4 .or. frm == 5) then
    write(dat, '(i0, a, i0)') ubound(b, 1) - lbound(b, 1) + 1, ' ', ubound(b, 2) - lbound(b, 1) + 1
  else
    write(dat, '(i0, a, i0)') (ubound(b, 1) - lbound(b, 1) + 1) / 3, ' ', ubound(b, 2) - lbound(b, 2) + 1
  end if
  write(iunit) trim(dat)
end if

if (frm >= 1 .and. frm <= 3) then
  if (frm == 2 .or. frm == 3) then
    write(iunit, '(i0)') 255
  end if
else
  if (frm == 5 .or. frm == 6) then
    write(dat, '(i0)') 255
    write(iunit) trim(dat)
  end if
end if

do iy = ubound(b, 2), lbound(b, 2), -1
  do ix = lbound(b, 1), ubound(b, 1)
    !write(iunit, '(i0, a)', advance = 'no') b(ix, iy), ' '
    if (frm >= 1 .and. frm <= 3) then
      write(iunit, '(i0, a)', advance = 'no') ichar(b(ix, iy)),' '
    else
      write(iunit) b(ix, iy)
    end if
  end do
  if (frm >= 1 .and. frm <= 3) then
    write(iunit, '(a)', advance = 'yes') ''
  end if
end do

close(iunit)

end subroutine writepbm

!=======================================================================

! h in [0, 360], s in [0, 1], v in [0, 1]

! rgb in [0, 255]

function hsv2rgb(hsv)

double precision :: rgb(3), hp, c, x, m, hsv(3)

integer :: hsv2rgb(3)

c = hsv(2) * hsv(3)
hp = hsv(1) / 60.d0
x = c * (1.d0 - abs(mod(hp, 2.d0) - 1.d0))

if      (0.d0 <= hp .and. hp < 1.d0) then
  rgb = [c, x, 0.d0]
else if (1.d0 <= hp .and. hp < 2.d0) then
  rgb = [x, c, 0.d0]
else if (2.d0 <= hp .and. hp < 3.d0) then
  rgb = [0.d0, c, x]
else if (3.d0 <= hp .and. hp < 4.d0) then
  rgb = [0.d0, x, c]
else if (4.d0 <= hp .and. hp < 5.d0) then
  rgb = [x, 0.d0, c]
else if (5.d0 <= hp .and. hp <= 6.d0) then
  rgb = [c, 0.d0, x]
else
  write(*,*)
  write(*,*) 'ERROR in hsv2rgb'
  write(*,*) 'Hue outside of range [0, 360]'
  write(*,*) 'Hue = ', hsv(1)
  write(*,*)
  stop
end if

m = hsv(3) - c
rgb = rgb + m

hsv2rgb = min(255, floor(rgb * 256.d0))

if (debug >= 3) print *, ''
if (debug >= 3) print *, 'rgb = ', rgb
if (debug >= 3) print *, 'hsv2rgb = ', hsv2rgb

end function hsv2rgb

!=======================================================================

double complex function f(z, c)

double complex :: z, c

f = z ** 2 + c

end function f

!=======================================================================

integer function nitrescape(c, maxitr, escape)

double precision :: escape

double complex :: c, z

integer :: maxitr

z = c
nitrescape = 0
do while (nitrescape < maxitr .and. abs(z) < escape)
  nitrescape = nitrescape + 1
  z = f(z, c)
end do

end function nitrescape

!=======================================================================

subroutine testpbm

!integer, allocatable :: b(:,:)
character, allocatable :: b(:,:)
integer :: ix, iy

allocate(b(900, 360))

do ix = 1, 300
  do iy = 1, 360
    b(3 * ix - 2: 3 * ix, iy) = achar(hsv2rgb([dble(iy), 1.d0, 1.d0]))
  end do
end do

call writepbm(6, b, 'test')

end subroutine testpbm

!=======================================================================

end module fmod

!=======================================================================

program fractal

use fmod

implicit none

character :: fname*256, ct*6, fdir*256

double precision :: xmin, xmax, ymin, ymax, dx, dy, escape, h
double precision :: xmin0, ymin0, xmax0, ymax0, xc, yc, zoom, znt
double precision :: dxmax, dxmin, dymax, dymin, hm
double precision, allocatable :: x(:), y(:)

double complex :: c

integer :: nx, ny, maxitr, i, ix, iy, nitr, t0, t, crate, frm, nt, it
!integer, allocatable :: b(:,:)
character, allocatable :: b(:,:)

logical :: fexist

!call testpbm
!stop

call system_clock(t0)
call system_clock(count_rate = crate)

write(*,*)
write(*,*) 'Enter file format (1 - 3):'
read(*,*) frm

write(*,*)
write(*,*) 'Enter escape radius:'
read(*,*) escape

write(*,*)
write(*,*) 'Enter maximum number of iterations:'
read(*,*) maxitr

write(*,*)
write(*,*) 'Enter initial min/max x bounds:'
read(*,*) xmin0, xmax0

write(*,*)
write(*,*) 'Enter initial min/max y bounds:'
read(*,*) ymin0, ymax0

write(*,*)
write(*,*) 'Enter zoom center x/y coordinates:'
read(*,*) xc, yc

write(*,*)
write(*,*) 'Enter final zoom magnification:'
read(*,*) zoom

write(*,*)
write(*,*) 'Enter number of frames:'
read(*,*) nt

write(*,*)
write(*,*) 'Enter number of x/y pixels:'
read(*,*) nx, ny

write(*,*)
write(*,*) 'Enter pre-modulo hue multiplier:'
read(*,*) hm

write(*,*)
write(*,*) 'Enter file name:'
read(*,*) fname

write(*,*)
write(*,*) '====================================================='

write(*,*)
write(*,*) 'format             = ', frm
write(*,*) 'escape             = ', escape
write(*,*) 'maxitr             = ', maxitr
write(*,*) 'xbounds            = ', xmin0, xmax0
write(*,*) 'ybounds            = ', ymin0, ymax0
write(*,*) 'Zoom center        = ', xc, yc
write(*,*) 'Zoom magnification = ', zoom
write(*,*) 'Frames             = ', nt
write(*,*) 'Image size         = ', nx, ny
write(*,*) 'Hue multiplier     = ', hm
write(*,*) 'File name          = ', trim(fname)

write(*,*)
write(*,*) '====================================================='

allocate(x(nx))
allocate(y(ny))

if (frm == 1 .or. frm == 2) then
  allocate(b(nx, ny))
else
  allocate(b(3 * nx, ny))
end if

fdir = 'frames'

! TODO:  hide errors for all OSs
call system('mkdir "'//fdir//'"')

znt = zoom ** (1.d0 / dble(nt))

dxmax = xmax0 - xc
dxmin = xc - xmin0
dymax = ymax0 - yc
dymin = yc - ymin0

do it = 0, nt

  write(*, '(a, i0)') 'frame = ', it

  write(ct, '(i0)') it
  !print *, 'ct = ', ct

  xmax = xc + dxmax * znt ** (-it)
  xmin = xc - dxmin * znt ** (-it)
  ymax = yc + dymax * znt ** (-it)
  ymin = yc - dymin * znt ** (-it)

  dx = (xmax - xmin) / dble(nx - 1)
  dy = (ymax - ymin) / dble(ny - 1)

  if (debug >= 1) print *, 'dx, dy = ', dx, dy
  if (debug >= 2) print *, 'xmin, xmax = ', xmin, xmax
  if (debug >= 2) print *, 'ymin, ymax = ', ymin, ymax

  x = [(xmin + dble(i) * dx, i = 0, nx - 1)]
  y = [(ymin + dble(i) * dy, i = 0, ny - 1)]

!$OMP parallel shared(b, x, y, nx, ny, maxitr, escape, frm)
!$OMP do schedule(dynamic)
  do iy = 1, ny
    do ix = 1, nx

      c = complex(x(ix), y(iy))
      nitr = nitrescape(c, maxitr, escape)
      if (debug >= 3) print *, 'nitr = ', nitr

      if (frm == 1) then

        ! B & W
        if (nitr == maxitr) then
          !b(ix, iy) = 0
          b(ix, iy) = achar(0)
        else
          !b(ix, iy) = 1
          b(ix, iy) = achar(1)
        end if

      else if (frm == 2) then

        ! Grayscale
        !b(ix, iy) = mod(nitr, 256)
        b(ix, iy) = achar(mod(nitr, 256))

      else if (frm == 3) then

        ! RGB

        !! Red/black contour
        !b(ix, iy) = mod(nitr, 256), 0, 0

        ! HSV map
        if (nitr == maxitr) then
          !b(3 * ix - 2: 3 * ix, iy) = [0, 0, 0]
          b(3 * ix - 2: 3 * ix, iy) = achar([0, 0, 0])
        else

          !h = mod(180.d0 + 360.d0 * dble(nitr) / maxitr, 360.d0)
          h = 360.d0 * mod(hm * dble(nitr) / maxitr, 1.d0)
  
          !b(3 * ix - 2: 3 * ix, iy) = hsv2rgb([h, 1.d0, 1.d0])
          b(3 * ix - 2: 3 * ix, iy) = achar(hsv2rgb([h, 1.d0, 1.d0]))

        end if ! RGB color map style
      end if   ! frm
    end do     ! ix
  end do       ! iy

!$OMP end do
!$OMP end parallel

  call writepbm(frm, b, trim(fdir)//'/'//trim(fname)//'_'//trim(ct))

end do         ! it

call system_clock(t)

write(*,*)
!print *, 't, t0, crate = ', t, t0, crate
write(*,*) 'Elapsed time = ', dble(t - t0) / dble(crate)
write(*,*)

end program fractal
